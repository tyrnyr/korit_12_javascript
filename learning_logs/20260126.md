## default function parameter
```js
// 02_default_function_parameter.js
// 함수 정의
function say(message) {
  if(message != undefined) console.log(message);
  else console.log('매개변수가 넘어오지 않았습니다.');
}

// 함수 호출
say();

/**
 * 이상의 코드에서 함수의 매개변수인 message 값을 전달하지 않으면 message는 undefined가 됩니다. 만약에 이 매개변수가 특정 기능을 구현하기 위해 반드시 값이 필요하다면 매개 변수 값이 비어있을 때는 오류가 발생하게 될겁니다. 그래서 say() 내에 값이 있는지 없는지를 체크하는 로직이 필수적으로 요구됩니다.
 * 
 * default function parameter는 함수 호출 시에 argument가 아예 없다면 미리 등록되어있는 값을 대입해주는 기능이라고 할 수 있습니다.
 */
function say2(message='매개변수가 넘어오지않았습니다2.') {
  console.log(message);
}
say2();
say2('argument에 값을 넣었습니다.');

//
```

## rest parameter

```js
//03_rest_parameter.js
function sum1(x1, x2) {
  let y = x1 + x2;
  return y;
}

console.log(sum1(5, 7));

function sum2(x1, x2, x3, x4) {
  let y = x1 + x2 + x3 + x4;
  return y;
}

console.log(sum2(5, 7, 1, 3));
/**
 * 일반적인 함수 정의는 매개변수를 몇 개 선언할지 미리 지정해두게 됩니다. 2 개 지정하면 무조건 argument가 두 개 필요하고 4 개 지정하면 4 개의 argument가 필요하겠네요.
 * 즉 정해진 argument를 충족하는 선에서 개발자가 머리 써서 몇 번 호출할지를 고민해야합니다. 범위를 벗어나게 되면 계산 자체가 불가능할 수도 있겠네요.
 * 
 * -> 이상의 문제를 해결하기 위한 것이 Rest Parameter의 개념입니다. 몇 개의 매개변수가 전달될지 모르는 경우에 사용.
 */
function sum3(...args) {  // 매개변수를 이렇게 설정하면, 함수 호출 시 매개변수 개수에 상관없이 할당이 가능하고, 이렇게 지정된 값은 '배열'로 저장됨.
  let total = 0;
  for(let x of args) {
    total += x;
  }
  return total;
}

console.log(sum3(1,2,3,4,5,6,7,8,9,10));
console.log(sum3(1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,));
```

## Arrow Function
04_arrow_function.js

```js
// 04_arrow_function.js

// 함수 선언식(가장 기초적인 함수 정의 방식)
function hello1(name) {
  return `Hello ${name}`;
}
// 함수 표현식(종종 쓰는데 화살표 함수랑 합쳐져서 더 많이 쓰입니다.)
const hello2 = function (name) {
  return `오하요 ${name}`;
}
// 화살표 함수의 정의 방식들 -> 람다식 때도 다양한 방법으로 정의했었습니다.

// 모든 소(중)괄호가 다 표기된 화살표 함수
const hello3 = (name) => {return `안녕하세요 ${name}`};

// 매개변수가 하나일 때는 소괄호 생략
const hello4 = name => {return `또 안녕하세요 ${name}`};

// 실행문이 한 줄일 경우에는 중괄호 생략 / 근데 return문일 경우 return도 생략
const hello5 = name => `또또 안녕하세요 ${name}`;

// 매개변수가 아예 없으면 비어있는 소괄호 사용
const helloEveryone = (name='여러분') => `안녕하세요 ${name}`;
```

## Object Literal Syntax Extension
- JS에서의 Object는 key-value property로 이루어져있는데 기본적으로 key는 string 자료형.
05_object_extension.js
```js
// 05_object_extension.js

let fName = 'Jone';   // 지금 얘는 임의적인 데이터값이고 FE상에서는
let lName = 'Doe';    // 브라우저의 입력을 받게 될 거기 때문에
// 변수의 선언과 값 대입이 반 필수적입니다.

let person = {
  firstName : fName,
  lastName : lName,
};
console.log(fName);
console.log(person.firstName);
console.log(person['firstName']); // key가 string이라는 것을 알 수 있는 예시겠네요.

/**
 * Object 상에서는 변수에 할당된 값을 key로 치환해서 사용하는 것은 불가능합니다.
 * 
 * 하지만 object literal syntax extension을 사용하면 object의 키로 변수에 할당된 '문자열' 값을 사용할 수 있습니다. 대괄호([])를 사용합니다.
 */

let type = 'student';
let score = {
  [type]: 'Jane',
  score: 95,
}

console.log(score.score);

console.log(score); // 결과값 : { student: 'Jane', score: 95 }
console.log(score.student);
/**
 * Object의 key를 동적으로 생성가능할 수 있다는 점 : input 태그를 통해서 객체의 key를 생성할 수 있겠네요.
 * 
 */
```

## Spread Operator(spread 연산자)
06_spread.js

```js
let arr1 = [ 4, 5, 6 ];
let arr2 = [ 1, 2, 3 ];
let arr3 = [ ...arr2, ...arr1 ];
console.log(arr3);  // 결과값 : [ 1, 2, 3, 4, 5, 6 ]
/*
배열, 문자열과 같이 iteration(반복가능자료형) 형태의 데이터를 element 하나하나로 분해해서 사용이 가능하다.
arr1, 2는 자료형이 배열이죠. -> ...arr1 / ...arr2는요, 자료형이 배열이 아닙니다.
4, 5, 6이라는 각각의 element와 1, 2, 3이라는 각각의 element입니다. 즉 자료형을 착각하기가 너무 쉽습니다.

아까전에 ...args라고 했을 때 spread 연산자가 도입되어있습니다.
*/


let cd = 'CD';
let alphabets = ['A', 'B', ...cd ];   // 그러면 그 와중에 스프레드 연산자의 작성 순서도 중요하네요.
console.log(alphabets);
/**
 * 그럼 alphabets 내부의 element를 소문자로 바꾸고 싶다면 내부로 들어가서 .toLowerCase()를 적용하면 되겠네요.
 */
// 기본 for문
for(let i = 0 ; i < alphabets.length ; i++){
  console.log(alphabets[i].toLowerCase());
}
// 어떤 for문을 쓸것인가 in / of
console.log('향상된 for-of문 사용');
for (let alphabet of alphabets) {
  console.log(alphabet.toLowerCase());
}
```

## Object Destructuring
객체 구조분해
07_object_destructring.js
```js
function getPerson() {
  return {
    fName: '영',
    lName: '김',
    age: 20,
    email: 'kim0@test.com',
    city: '부산광역시',
    contry: '대한민국',
  };
};
// 이상의 코드가 있다고 가정했을 때 email 값과, city의 값을 출력하고 싶다면 어떡해야 할까요.
// 실행 예
/**
 * 해당 지원자는 부산광역시에 살고 있으며23 email은 kim0@test.com입니다.
 */
let kim0 = getPerson();     // 함수 호출 결과가 object니까 걔를 변수에 대입한 다음
console.log(`해당 지원자는 ${kim0.city}에 살고 있고 email은 ${kim0.email}입니다.`); //객체명.key값을 통해서 해당 value를 불러냈습니다.

let kimEmail = getPerson().email;   // 애초에 객체의 특정 key의 value만 변수에 저장하고
let kimCity = getPerson().city;
console.log(`해당 지원자는 ${kimCity}에 살고 있고 email은 ${kimEmail}입니다.`); 
// 콘솔에 찍힐 수 있도록 했습니다.

// 객체의 추출하고자 하는 key와 동일한 변수를 선언합니다. {} 내에.
let {email, city} = getPerson();  // 이렇게 쓰면 email이라고 하는 변수에 getPerson().email의 value 값이, city라고 하는 변수에 getPerson().city의 변수값이 들어갑니다.
console.log(`해당 지원자는 ${city}에 살고 있고 email은 ${email}입니다.`); 

function displayFullName({fName, lName}) {  // 매개변수가 구조분해되어있음을 {}로 알 수 있음
  console.log(`${lName} ${fName}`);
}

displayFullName(getPerson()); // 그러면 argument로는 key로 fName / lName을 가지고 있는 애가 필수적으로 요구됩니다. - 호출시의 argument와 정의 시의 매개변수의 차이점에 주목할 것. -> React에서 허구한 날 쓰이기 때문에 꼭꼭꼭꼭 알아둘 것.
```
## Array Destructuring
08_array_destructuring.js

# JavaScript 주요 Web APIs
## LocalStorate / SessionStorage
1. LocalStorage
  - 저장된 데이터를 삭제하기 전까지 영구히 보존됨. 저장되는 모든 데이터는 JS 객체처럼 key - value pair로 이루어져있습니다. 단, 저장되는 모든 데이터 값은 string으로만 저장가능합니다. 그래서 이 저장소에 number, object, boolean, array 등과 같은 string이 아닌 데이터를 저장할 때는 JSON.stringify를 통해 문자열로 변환하여 저장해야 합니다. 그리고 localStorage의 데이터를 JS로 읽고 싶다면 JSON.parse()를 사용하여 객체로 변환해줘야 연산이 가능합니다.
  - 로컬스토리지는 보안에 위배되지 않고, 영구히 저장해도 상관없는 데이터를 저장할 때 적합.
    - 사용자가 마지막으로 보고 있는 화면 url 저장.
    - 웹 사이트에서 사용자 테마, 개인화를 제공하는 경우 해당 정보 저장.
09_local.js / 09_local.html

```js
// 로컬스토리지에 데이터를 저장하는 예제
if(typeof Storage !== 'undefined') {
  localStorage.setItem('title', '위대한개츠비');
}

const users = [
  {id: 1, name: 'Kim'},
  {id: 2, name: 'Lee'}
];
localStorage.setItem('users', JSON.stringify(users));

console.log(users);
console.log(JSON.stringify(users));

// 다시 받아오는 부분
if(typeof Storage !== 'undefined') {
  console.log(localStorage.getItem('title')); // key를 통해 value를 확인합니다.
  console.log(localStorage.getItem('users'));
  // 당연히 'user' key를 통해서 불러오더라도
  // 결과값 : [{"id":1,"name":"Kim"},{"id":2,"name":"Lee"}] 이기는합니다. 하지만 얘는 기본적으로 string이기 때문에 users[0].id와 같은 연산이 불가능합니다.
  console.log(JSON.parse(localStorage.getItem('users')));
}

let users2 = JSON.parse(localStorage.getItem('users'));
let kim = users2[0].name; // 추가 연산을 한 사례
console.log(kim);
```
- 이상의 코드의 주의 사항으로는 localStorage를 참조해야 하기 때문에 html 파일도 요구됩니다. live server에서 확인할 것.

2. SessionStorage
- localStorage는 지우기 전까지 영구 보존됩니다.
- sessionStorage는 새로고침하면 다 날라갑니다.