# JavaScript
## 조건문
### if-else if-else
### switch
  switch문에서는 조건문과 달리 비교 연산을 통한 true/false를 뽑아내는 식이 switch()의 소괄호 내에 들어가지 않습니다.
```js
switch(변수/상수) {
  case 값1:
    실행문1
    break;
  case 값2:
    실행문2
    break;
  default:
    실행문default;
    (break;)
}
```
- if문과 switch문의 차이
if문은 조건식 내에 비교 연산을 사용할 수 있기 때문에 switch문보다 더 자주 사용됩니다. 하지만 if문의 경우 조건식을 위에서부터 차례대로 순차 비교를 하기 때문에 운 나쁘게 맨 밑에 조건이 당첨된다면 그만큼 속도가 느려진다는 문제가 있습니다. 그래서 비교 연산이 필요 없고 조건을 비교할 대상이 범위가 아니라 특정 값인 경우에는 switch가 더 선호됩니다.

## 반복문
ch03_loops
- 종류
  1. for
  2. for-in
  3. for-of
  4. while
### for-loop
01_for_loop.js
### for-in-loop
- 이거 그냥 향상된 for문입니다.
- Java에서는 향상된 for문을 사용할 경우 인덱스 넘버가 없는 애들도 출력이 가능했습니다(Set 자료형의 경우).
- JS에서도 인덱스가 없는 자료형의 element를 추출할 때 for-in 반복문을 사용하게 됩니다.
- 가장 대표적으로는 JavaScript의 객체의 value를 추출할 수 있습니다.

### for-of-loop
- 근데 얘도 향상된 for문입니다.
- 03_for_of.js

# 함수(function)
## 정의
- 다양한 작업을 하나의 단위로 묶어놓은 코드블록
## 함수의 정의 및 사용
1. 함수 선언식
```js
function 함수명(매개변수1, 매개변수2) {
  실행문;
  return이 optional
}
function add(a, b) {
  let sum = a + b;
  return sum;
}
```
2. 함수의 호출
```js
let sumNum = add(1, 2);    //는 근데 아무런 콘솔상에서의 결과값이 없겠네요. return 썼으니까.
console.log(sumNum);
```
ch04_functions / 01_function1.js

3. 함수 표현식(arrow function)
02_function2.js
함수 표현식은 _변수에 함수를 할당해서 사용하는 방식_ 입니다.
- 어제 말한 것처럼 메서드의 결과값이 변수에 들어가는게 아니라 함수 자체가 변수에 들어갑니다.
- 형식
```js
선언자 변수명 = 함수명(매개변수1, 매개변수2) {
  실행문
  return값
}
let sum = function(a, b) {
  return a + b;
}
```

```js
let sum00 = sum(10, 5);   // 함수를 변수에 저장하니까 순서를 지키게 되어 오류가 발생
console.log(sum00);


// 함수 표현식 정의
let sum = function(a, b) {
  return a + b;
}
// 함수 호출
sum1 = sum(1, 2);
console.log(sum1);
sum2 = sum(3, 4);
console.log(sum2);
```
함수 및 함수 표현식의 경우 차이가 없어 보이지만 실행 측면 상에서의 차이가 존재합니다. 일반적인 함수 선언의 경우에는 정의 영역이 호출 영역보다 뒤에 있다고 하더라도 정상 작동을 합니다.

이는 JS 해석(인터프리터) 엔진이 일반적으로 선언된 함수의 경우 먼저 읽어들이기 때문에(호이스팅) 호출 구문이 선행하더라도 문제가 없습니다.

그런데 변수에 함수를 할당하는 함수 표현식의 경우 let 선언자로 인해 선언된 순서를 읽기 때문에 정의가 먼저 되어야지만 호출이 정상적으로 이루어집니다.

4. Function 생성자 함수
```js
let sum = new Function('a', 'b', 'return a + b;');
let sum1 = sum(1, 2);
let sum2 = sum(3, 4);
```
## 함수를 사용하는 이유
- 특정 기능을 하는 코드 블록을 작성하면 해당 함수가 갖는 기능이 필요할 때마다 호출만 하면 되기 때문에 효율성이 높습니다. 같은 코드를 재작성할 필요가 없기 때문에 장점이 있고, 또한 기능 변경이 일어날 때 전체 코드를 수정하는 게 아니라 특정 함수 내부의 로직만 수정하면 호출 부분은 자동으로 수정사항이 반영됩니다.

1. 코드의 재사용성이 높다. 
2. 코드의 유지보수성이 높다.
3. 함수의 이름이 직관적인 경우에 코드 가독성이 높다.

# JavaScript 내장 객체
- 내장 객체가 가지고 있는 다양한 함수(메서드)의 기능을 파악하고 있을 때, 이를 조합하여 사용자 정의 함수 및 메서드를 정의하게 되면 가독성이 높은 코드를 작성할 수 있습니다.

## Object 객체
내장 객체(Built-in Object)는 브라우저의 JS 엔진에 내장된 객체를 의미하는데, Object 객체는 모든 JS의 루트 객체에 해당합니다. JS에는 String / Number / Date / Array / Math 등 다양한 객체가 존재합니다.

```js
// 빈 객체 생성
let person = new Object();
// 멤버 설정
person.fName = '영';
person.lName = '김';
person.age = 20;
person.getFullName = function() {
  return this.lName + ' ' + this.fName;
}
console.log(person.getFullName());    // 결과값 : 김 영
```
이상의 코드에서 person이라는 객체의 property는 fName / lName / age / getFullName라는 key를 가지고 있고 value로 각각 string / string / number / 함수 가 담겨있습니다. 그러면 person객체에 있는 getFullName()은 함수니까 method라고 할 수 있겠네요.

## String 객체
1. length - 문자열 길이를 반환
2. indexOf() - 문자열 내에 특정 문자열이 존재하는지를 찾고, 있드면 문자열이 시작되는 index를 return합니다. 없으면 -1을 return합니다.
ch05_builtin_objects -> 01_builtin.js
3. lastIndexOf() - 
4. slice() - 

## Number 객체
1. toString()
2. toExponential() - 숫자를 지수형으로 반환해주는데, 과학 및 공학에서 자주 쓰임.
3. toFixed() - 소수점 몇째자리까지 보여줄지 결정함. 지정된 소수점 자리 수 아래에서 반올림함.
4. toPrecision() - 정수와 소수를 포함해서 몇 번째자리까지 보여줄지를 결정함.
```js
let x = 10.656;
x.toPresision();    // 10.656
x.toPresision(2);    // 11
x.toPresision(4);    // 10.66;
```
5. parseInt() - 함수로서 'int'형태로 반환하기 때문에 실수를 정수형태로, 혹은 문자열을 정수형태로 반환
```js
parseInt('-10'); // -10
parseInt('-12.33'); // -12
parseInt('10'); // 10
parseInt('12.33'); // 12
parseInt('10 20 30'); // 10
parseInt('10 years'); // 10
parseInt('years 10'); // NaN (Not a Number)
```
6. parseFloat()
```js
parseFloat('10'); // 10
parseFloat('12.33'); // 12.33
parseFloat('10 years'); // 10
parseFloat('years 10'); // NaN
```
7. Number 객체의 property
  1.MAX_VALUE - JS에서 다룰 수 있는 최대 수
  2.MIN_VALUE - JS에서 다룰 수 있는 가장 작은 수
  3.POSITIVE_INFINITY - infinity
  4.NEGATIVE_INFINITY - -infinity
  5.NaN - Not A Number

## Array 객체
1. toString()
2. join() - 배열 안의 모든 문자를 argument 상에있는 문자를 사용하여 결합함.
3. pop() - 배열에서 마지막 데이터를 제거하고 마지막 데이터를 return함.
4. push() - 배열에 새로운 element를 더하는 메서드
5. shift() - 배열에서 첫 번째 element를 제거하고 return함.
  - 실무 사용 사례
    - 스택(stack)과 큐(Queue)는 자료구조 유형 중에 가장 많이 쓰이는 것들 두 가지로, 이 중 큐는 들어온 순서대로 쌓이고, 출력 시에는 첫 번째 데이터부터 출력합니다. 이 큐를 선입선출(FIFO - first in first out)이라고 합니다.
    - 배열은 데이터가 순서대로 저장되기 때문에 큐 자료구조를 구현할 때 shift() 메서드와 함께 사용하면 배열의 가장 첫 번째 데이터부터 차례대로 뽑을 수 있기 때문에 FIFO를 구현하기에 가장 좋습니다.
6. unshift() - 배열의 맨 앞에 element를 추가하고, 배열 길이를 return
7. 배열의 element 변경
```js
let fruits = [1,2,3];
fruits[0] = 0;
console.log(fruits); //결과값 [0, 2, 3]
```
8. splice() - 새로운 element를 특정 위치에 추가하는 메서드. 추가 시에는 기존 element를 삭제할 수도 있음.
```js
let fruits = ['banana', 'orange', 'apple', 'mango'];
fruits.splice(2, 0, 'lemon', 'kiwi');
console.log(fruits);  // 결과값 : ['banana', 'orange', 'lemon', 'kiwi', 'apple', 'mango'];
```
  splice(p1, p2, p3...)
  p1 - 새로운 element를 추가할 인덱스 넘버 -즉 2번지에 추가하겠다
  p2 - 인덱스 넘버에서 요소를 추가하기 전에 삭제할 요소 수 - 0이니까 삭제 안하겠다
  p3...pn - 추가할 element들(복수로 가능)
9. concat() - 두 개 이상의 배열을 하나로 결합
```js
let names1 = ['김영', '김일'];
let names2 = ['김이', '김삼'];
let names3 = ['김사', '김오'];
let newNames = names1.concat(names2, names3);
```
10. slice(p1, p2) slice(시작값, 한계값)
11. sort() - 문자형 데이터가 있는 경우 오름차순으로 정리합니다.
  - 내림차순 정렬 배열명.reverse()
12. filter() - 배열에서 특정 조건을 만족하는 배열의 element들만 찾아서 _새로운 배열_ 로 return
  - 배열을 다룰 때 가장 많이 사용하게 되는 내장 함수 중 하나로, 특정 조건을 만족하는 데이터만 추출하는 프로그램을 작성할 때가 많은데, 이때 사용합니다.
  - 형식
  ```js
  배열명.filter(콜백함수(element[, index[, arr]])[, thisArgs])
    - element - 처리할 현재 element에 해당합니다(numbers 그 안의 0 번지인 number)
    - index(optional) - 처리할 현재 element의 index 넘버
    - arr - 배열 전체
  ```
  - callback 함수 : 배열의 내부 element들 하나하나에 적용되는 별개의 함수. filter() 와 합쳐지게 됐을 경우 특정 조건을 만족한 것들은 return되고, 만족하지 못한 것들은 버려지는 로직이 작성됩니다.

```js
let persons = [
  {
    name: '김영',
    point: 78,
    city: '서울',
  },
  {
    name: '김일',
    point: 98,
    city: '서울',
  },
  {
    name: '김이',
    point: 76,
    city: '제주',
  },
  {
    name: '김삼',
    point: 81,
    city: '부산',
  },
];

let personResult = persons.filter(function(person) {
  return person.point > 80;
})
console.log(personResult);
```

13. map() - 배열 데이터가 Object 형일 때, 배열에 담긴 Object를 새로운 Object로 변환한 다음에 새로운 배열로 return함.
```js
let userList = [
  {
    fName: '영',
    lName: '김',
    email: 'b@test.com',
  },
  {
    fName: '일',
    lName: '김',
    email: 'c@test.com',
  },
  {
    fName: '이',
    lName: '김',
    email: 'd@test.com',
  },
  {
    fName: '삼',
    lName: '김',
    email: 'e@test.com',
  },
  {
    fName: '사',
    lName: '김',
    email: 'f@test.com',
  },
];

let modifiedUSerList = userList.map(function(user){
  return {
    fullName: user.lName + user.fName,
    lName: user.lName,
    fName: user.fName,
    email: user.email,
  };
})
console.log(modifiedUSerList);
```

## JSON 객체
- 데이터를 저장하거나 전송할 때 많이 사용되는 DATA 교환 형식이라고 수업했습니다. 
- 특징
  1. 서버와 클라이언트 간 데이터 전송 시 많이 사용됨.
  2. JS의 Object 표기법과 매우 유사합니다.
  3. JSON 데이터는 JS의 JSON 객체의 .parse() 를 이용하면 JS 객체로 변환해서 사용이 가능합니다.
  4. 프로그래밍 언어 독립적입니다.
  5. 대부분의 언어에서 JSON 데이터를 처리할 수 있는 라이브러리를 제공합니다(Java에서는 GSON이었습니다).

03_builtin_json.js

```js
let data = {
  "employees" : [
    {"fName" : "영", "lName" : "김"},
    {"fName" : "일", "lName" : "김"},
    {"fName" : "이", "lName" : "김"}
  ]
};
// console.log를 통해서 김이를 추출하시오.
console.log(data.employees[2].lName + data.employees[2].fName);
console.log(data);

let stringValue = JSON.stringify(data); // 객체를 string으로 바꿔주겠네요. 그런데 어떻게? JSON 형태에 맞게.
console.log(stringValue);

let text = '{"employees":[{"fName":"zero","lName":"김"},{"fName":"one","lName":"김"},{"fName":"two","lName":"김"}]}'; 

let jsObj = JSON.parse(text);
console.log(jsObj);

/*
JS Object <-> JSON로 왔다갔다 하는 부분은 매우매우매우 자주 일어납니다.
JSON.parse(JSONString); 과 JSON.stringify(JSObject);는 항상 사용하는 형태라고 생각하시면 됩니다.
*/
```
- JSON.stringify() : 데이터를 서버로 전송하기 위해서는 데이터를 문자열 형태로 변환해야 하기 때문에 해당 메서드를 사용합니다. stringify : string 화 하다.
- JSON.parse() : 문자열을 argument로 하여 JS 객체로 변환하여 줍니다.

## Window 객체
04_window_object.html
1. alert()
2. confirm()
3. prompt()
4. open()
5. setTimeout() / clearTimeout()
  - setTimeout()은 두 번째 argument로 지정한 시간 간격 이후 첫 번째 argument에 정의한 callback 함수를 실행하는 함수입니다.

  ```html
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body bgcolor="5f5f5f">
  <script>
    // window는 전역이라서 window.을 꼭 명시 안해도 됩니다.
    //alert('이것은 alert입니다.');
    //confirm('정말 삭제하시겠습니까?');
    //prompt('비밀번호를 입력하세요.');
    //open('https://www.naver.com');
    let myExec;
    function myFunction() {
      myExec = setTimeout(function(){console.log('5초 후 프로그램 실행');} ,5000);
    }
    myFunction();
  </script>
</body>
</html>
  ```

  clearTimeout() : setTimeout()에서 정의한 콜백함수가 실행되지 않았다면 함수 실행 중지를 clearTimeout() 통해서 함수 실행을 중지시킬 수 있습니다.

  # JavaScript 고급 문법
  1. Default Function Parameter
  2. Rest Parameter
  3. Arrow Function
  4. Template Literals